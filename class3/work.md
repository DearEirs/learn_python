### 1、谈输入处理输出 计算控制存储
```
输入：数据结构
处理：算法(数据结构+操作)其中数据结构属于输入
输出：通过对数据结构的操作所得出的结果

计算：计算器  对数据进行计算处理
控制：控制器  控制计算器下一步该执行什么命令
存储：用于存放数据,寄存器--高速缓存--二级缓存--内存--外存(硬盘)

理解：

硬件：
显示器  
输入：带有各个颜色的像素点
处理：通过特定的方式把像素点按一定规律排序
输出：用户所看到的各种图形

软件：
pgadmin 查询数据库
输入：用户的输入相应sql指令
处理：把指令通过网络形式传到远程数据库端执行,并把结果传回
输出：执行SQL所返回的结果

在处理问题的时候,先确定自己需要的结果(输出)是什么,然后才可以确认你需要做什么(输入),需要怎么样去做(处理)才可以把事情做得更好
```

### 2、总结课程内容
```
冯诺依曼体系：
核心观点：输入处理输出,计算控制存储
计算机的程序和带处理的数据都无差别地存储在存储器中

编程语言的发展
穿孔式编程--直接写在硬件上
汇编--使用不同的单词来对应不同的计算机指令(直接操作机器)
fortran--比汇编稍微高级
C--面向过程的高级语言
python、java、R 等其他高级语言 
高级语言都是通过解释器来把程序代码转换成对应的计算机指令来让计算机执行,计算机实际执行的还是二进制的机器码
硬件工程师会假设使用者已经了解硬件的使用方式,但是实际不是如此,编程语言很多时候都把底层结构的差异屏蔽掉,
所以想要写出精美的程序,还是有必要去大致了解一下计算机硬件的实现

语言的自举：自己能够靠自己来产生新的事物
自同构性：自己与自己重复,变得更加复杂

GIL(global interpreter lock) Cpython才有
利端：简化并发编程的复杂度,使得CPython对程序员更友好,在并发编程时无需考虑过多的其他因素即可在损耗一定性能的情况下达到预期效果 
弊端：每个线程运行时都需要拿到这个锁才可以运行,所以实际上同时只能运行1个线程
ps：在做阻塞的系统调用时,或者调用C语言写的扩展库时,GIL都会得到释放,当前有阻塞调用、或在执行C库的线程,都会让出CPU。
```

### 3、计算机体系结合工作   业务上能有什么优化  请写出
```
现有项目：
用户带数据访问API(输入)-->nginx-->程序(处理)-->tair缓存数据库或通过web访问后端数据源-->返回数据给用户(输出)
输入、输出内容不确定
输入的数据(json,必须的3个字段)
输出的数据(dict)
优化思路：
存储速度优化：
在现有的数据量下,使用tair当缓存数据库是否合适,redis或memcached的存储速度会不会更快
处理优化：
算法--数据结构+操作
数据结构 现在使用dict,数据长度固定,且不需要对数据进行修改  是否可用namedtuple代替
操作：用更高级的CPU运算代替当前运算(10+10+10+……+10=10*10*10=10^3)

脚本：
需求：输入uri,时间戳,password,把password+uri+时间戳的字符串md5加密然后输出一个完整的nginx secute link url

1.明确输出: 一个URL(带有uri+password+当前时间戳 拼接起来的字符串的MD5值)
2.明确输入：uri,password,当前时间戳,url_prefix
3.处理：把url_prefix与uri+password+当前时间戳的MD5值给拼接起来并输出
计算：字符串拼接
存储：由于URL有时效性,对持续性要求不高,直接存储在内存上

import md5
import sys
import time


uri = input('Please enter uri:')
password = 'mypassword'
t = time.time() + 300
url_prefix = 'http://192.168.0.1?md5='

md5_str = uri + password + str(int(t))
m1 = md5.new()   
m1.update(md5_str)   
url = url_prefix + m1.hexdigest()   
print(url)

优化思路：
存储速度优化：
都是一些简单的计算,且存储量十分少,能否直接放到寄存器里边？
处理优化：
字符串拼接方式,使用占位符 或者 format是否更快  测试中format更快
```

### 4、dict 实现 key value 怎么安排到内存
```
内存就像一张excel表一样,那么可以把key放到第一个格子上然后把value存放到key的下一个格子,
这样知道key的内存地址时就可以计算出value的内存地址
问题：
如果dict的key或value都已经存在内存上时,就不能按预期的方式去把key value写入到内存中
想法：
能否像list那样（在第一个元素有1个指向第二个元素的指针） 在key存在的内存方块中指向到value内存地址
```
