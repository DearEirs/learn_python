# SICP in Python

## 第一章

Debug指导原则:

- 逐步测试(Test incrementally)：每个编写的好的程序都是由可单独测试的、小型的、模块化的组件组成。尽快测试你写好的任何东西来及早捕获错误，并且从你的组件中获得自信。
- 隔离错误(Isolate errors)：复杂程序的输出、表达式、或语句中的错误，通常可以归于特定的组件模块。当尝试诊断问题时，在你能够尝试修正错误之前，一定要将它跟踪到最小的代码片段。
- 检查假设(Check your assumptions)：解释器将你的指令执行为文字 -- 不多也不少。当一些代码不匹配程序员所相信的（或所假设的行为，它们的输出就会是非预期的。了解你的假设，之后专注于验证你的假设是否整理来调试。
- 询问他人(Consult others)：你并不是一个人！如果你不理解某个错误信息，可以询问朋友、导师或者搜索引擎。如果你隔离了一个错误，但是不知道如何改正，可以让其它人来看一看。在小组问题解决中，会分享一大堆有价值的编程知识。


高级编程语言应该提供的三种机制:

- 基本的表达式和语句，它们代表该最简单的构建代码块
- 组合方式，复合元素由较简单的元素构成
- 抽象的手段，复合元素可以用它命名和操纵。


表达式求解:
- 数字求值为它标明的数值
- 名称求值为当前环境中这个名称所关联的值

嵌套表达式求解会
1. 求出运算符子表达式和操作数子表达式
2. 将作为操作符子表达式的值的函数应用于参数是操作数子表达式的值。

![image](https://github.com/wizardforcel/sicp-py-zh/blob/master/img/expression_tree.png)

上图为表达式树, 通过图片, 可以看出求出嵌套表达式mul(add(2, mul(4, 6)), add(3, 5))的结果时, 需要先求出表达式里边的子表达式的值, 如子表达式里边还有子表达式, 则继续循环下去, 然后再把得到的结果返回给上层表达式中参与计算


纯函数: 调用纯函数时, 除了返回一个值之外, 没有其他副作用
非纯函数: 调用非纯函数时, 除了返回一个值, 还会使编译器或计算机的状态发生改变.如print 返回None之外, 还会在console输出值

定义新函数:
```python
def func(arg1):
    return result

def <name>(<formal parameters>):
    return <return expression>
```
函数定义包含def语句，它标明了<name>（名称）和一列带有名字的<formal parameters>（形式参数）。之后，return（返回）语句叫做函数体，指定了函数的<return expression>（返回表达式），它是函数无论什么时候调用都需要求值的表达式
  
环境:
函数的定义:
```python
def square(x):
    return x * x

print(square)  --> <function square at 0x000001EA28893E18>
```
这里定义了一个用户自定义的函数square到全局帧上, 并把名称square与新定义的函数绑定, 可以看到函数内部本身有一个名称, 与之前定义的函数名称一样, **但是在环境中要求出一个名称的值,只会检查函数的名称, 而不会检查函数的内部名称**
```python
# 接上代码
f = square 
square = max
square(2)
```
如上, 当求square(2)的值时, 调用的其实是max函数, 而不会调用内部名称为square的函数.

而调用函数时, 引入了局部帧, 与全局帧不同, 全局帧只有1个, 其中包含所有内置函数的名称绑定, 而局部帧是每个函数都有的,属于自己的独立局部帧.它只能有该函数䣂访问.

调用用户自定义的函数时, 为了把参数应用到函数里边, 会有如下操作:
1. 在新的局部帧中, 把函数的形式参数绑定到实参的值上, 如f(2) 即把x这个名称绑定到2这个值上.
2. 从该帧开始到全局帧结束求出函数的主体

调用函数示例:
```python
from operator import add, mul


def square(x):
        return mul(x, x)
        
        
def sum_squares(x, y):
        return add(square(x), square(y))
        

sum_squares(5, 12)
```

![image](https://raw.githubusercontent.com/wizardforcel/sicp-py-zh/master/img/evaluate_sum_squares_3.png)

调用sum_squares(5, 12)时, 先进入了sum_squares函数的局部帧, 求值表达式为add(square(x), square(y)), 这需要先求出子表达式square(x)与square(y)的值, 这时进入了第二个局部帧square(5), 求值表达式为mul(5, 5) 可以得出结果25, 然后再进入到第三个局部帧square(12), 求出结果为144, 在把2个子表达式所求出的结果输入到add函数中进行计算.

局部名称:
实现者为函数的形式参数选择名称不应该影响函数的行为, 也就是函数应不依赖于编写者选择的参数名称.

命名准则:
- 函数名称应该小写，以下划线分隔。提倡描述性的名称。
- 函数名称通常反映解释器向参数应用的操作（例如print、add、square），或者结果（例如max、abs、sum）。
- 参数名称应小写，以下划线分隔。提倡单个词的名称。
- 参数名称应该反映参数在函数中的作用，并不仅仅是满足的值的类型。
- 当作用非常明确时，单个字母的参数名称可以接受，但是永远不要使用l（小写的L）和O（大写的o），或者I（大写的i）来避免和数字混淆。


复合语句:一般由一行以冒号结尾,标识了语句类型的header开头, 一个header与一组缩进的语句被称为子句, 复合语句由一个或多个子句组成

我们可以这样理解之前已经介绍过的语句：
- 表达式、返回语句和赋值语句都是简单语句。
- def语句是一个复合语句, 而接着def header的组定义了函数体

在def语句里边, 我们可以看到返回表达式并不会被立刻求值, 而是存储起来供以后定义的函数被调用时才会去求值.

我们可以这样理解多行的程序：执行一序列的语句时,先执行第一行语句, 如果第一行语句不是重定向控制, 如果序列语句还有剩下部分的话则继续执行

实践指导：在一组语句里边缩进时, 所有的行必须以相同的方式缩进（空格, 而不是制表符）,缩进的任何变化都会导致错误.

无论何时, 当用户定义的函数被调用时,套件中定义的一系列子句会在本地环境中被执行.

赋值语句的作用是在当前环境的第一个帧上把名称绑定到值上.

条件语句：Python 中的条件语句包含一系列的头部和语句组, 一个必需的if子句, 一个可选的elif子句, 和最后可选的else子句.

当执行条件语句时, 每个子句都是按顺序考虑的：
- 执行头部语句
- 如果头部语句为真, 则执行语句组, 然后跳过随后所有的条件语句

如果能到达else子句（仅当所有if和elif表达式值为假时）, 它的语句组才会被执行

布尔上下文：布尔上下文，条件块的头语句中的表达式被认为是布尔上下文：它们的真值对控制流很重要，但是它们的值永远不能被赋值或返回。Python中假的值包括：0、None、布尔值False。所有其他数字是真值。

布尔值：python中有2个布尔值, True和False, 布尔值表示逻辑表达式中的真值, 内置的操作符有 &gt;, &lt;, &gt;=, &lt;=, ==, !=

布尔运算符：python中内置的3个逻辑运算符(and, or, not)

要记住逗号会分隔赋值语句中的多个名称和值
```python
pred, curr = curr, pred + curr
```
这一行有将curr的值重新绑定到名称pred上,以及将pred + curr的值重新绑定到curr上的效果, 所有在=右边的表达式会在重新绑定被求值.

while子句包含一个头部表达式，然后是语句组

执行while子句:
- 求出头部表达式
- 如果它为真，执行语句组，然后返回到第一个步骤

> 在第二个步骤中, 整个while子句的语句组在头部表达式再次求值之前被执行. 为了防止while语句被无限地执行, 语句应该在每次执行时改变环境的状态.一个不会终止的while语句被称为死循环, 按下<Control>-C可以强制让 Python 停止循环

断言：程序员使用assert语句来验证预期, 如正在测试的函数的输出.断言语句在布尔上下文中有一个表达式，后跟一行带引号的文本行（单引号或双引号都很好，但是必须是一致的），如果表达式计算为false，则将显示该行.

当被断言的表达式求值为真时,断言语句的执行没有任何效果.当它是假时，asset会造成执行中断.

Doctest: Python提供了一个方便的方法，将简单的测试直接放在函数的文档字符串中, 文档字符串的第一行应该包含该函数的单行描述, 然后接着一个空白行, 参数和行为的详细说明可以跟在后边, 此外, 文档字符串可以包含调用该函数的简单交互式会话：
```python
def sum_naturals(n):
    """Return the sum of the first n natural numbers

    >>> sum_naturals(10)
    55
    >>> sum_naturals(100)
    5050
    """
    total, k = 0, 1
    while k <= n:
    total, k = total + k, k + 1
    return total
```
然后就可以使用 doctest 模块来验证交互
```python
>>> from doctest import run_docstring_examples
>>> run_docstring_examples(sum_naturals, globals())
```

在文件中编写Python时，可以通过使用doctest命令行选项启动Python来运行文件中的所有文件
```python
python3 -m doctest <python_source_file>
```

> 高效测试的关键是在实现新的函数之后（甚至是之前）立即编写（以及执行）测试。只调用一个函数的测试叫做单元测试。详尽的单元测试是良好程序设计的标志。
