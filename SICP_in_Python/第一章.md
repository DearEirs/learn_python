# SICP in Python

## 第一章

Debug指导原则:

- 逐步测试(Test incrementally)：每个编写的好的程序都是由可单独测试的、小型的、模块化的组件组成。尽快测试你写好的任何东西来及早捕获错误，并且从你的组件中获得自信。
- 隔离错误(Isolate errors)：复杂程序的输出、表达式、或语句中的错误，通常可以归于特定的组件模块。当尝试诊断问题时，在你能够尝试修正错误之前，一定要将它跟踪到最小的代码片段。
- 检查假设(Check your assumptions)：解释器将你的指令执行为文字 -- 不多也不少。当一些代码不匹配程序员所相信的（或所假设的行为，它们的输出就会是非预期的。了解你的假设，之后专注于验证你的假设是否整理来调试。
- 询问他人(Consult others)：你并不是一个人！如果你不理解某个错误信息，可以询问朋友、导师或者搜索引擎。如果你隔离了一个错误，但是不知道如何改正，可以让其它人来看一看。在小组问题解决中，会分享一大堆有价值的编程知识。


高级编程语言应该提供的三种机制:

- 基本的表达式和语句，它们代表该最简单的构建代码块
- 组合方式，复合元素由较简单的元素构成
- 抽象的手段，复合元素可以用它命名和操纵。


表达式求解:
- 数字求值为它标明的数值
- 名称求值为当前环境中这个名称所关联的值

嵌套表达式求解会
1. 求出运算符子表达式和操作数子表达式
2. 将作为操作符子表达式的值的函数应用于参数是操作数子表达式的值。

![image](https://github.com/wizardforcel/sicp-py-zh/blob/master/img/expression_tree.png)

上图为表达式树, 通过图片, 可以看出求出嵌套表达式mul(add(2, mul(4, 6)), add(3, 5))的结果时, 需要先求出表达式里边的子表达式的值, 如子表达式里边还有子表达式, 则继续循环下去, 然后再把得到的结果返回给上层表达式中参与计算


纯函数: 调用纯函数时, 除了返回一个值之外, 没有其他副作用
非纯函数: 调用非纯函数时, 除了返回一个值, 还会使编译器或计算机的状态发生改变.如print 返回None之外, 还会在console输出值

定义新函数:
```python
def func(arg1):
    return result

def <name>(<formal parameters>):
    return <return expression>
```
函数定义包含def语句，它标明了<name>（名称）和一列带有名字的<formal parameters>（形式参数）。之后，return（返回）语句叫做函数体，指定了函数的<return expression>（返回表达式），它是函数无论什么时候调用都需要求值的表达式
  
环境:
函数的定义:
```python
def square(x):
    return x * x

print(square)  --> <function square at 0x000001EA28893E18>
```
这里定义了一个用户自定义的函数square到全局帧上, 并把名称square与新定义的函数绑定, 可以看到函数内部本身有一个名称, 与之前定义的函数名称一样, **但是在环境中要求出一个名称的值,只会检查函数的名称, 而不会检查函数的内部名称**
```python
# 接上代码
f = square 
square = max
square(2)
```
如上, 当求square(2)的值时, 调用的其实是max函数, 而不会调用内部名称为square的函数.

而调用函数时, 引入了局部帧, 与全局帧不同, 全局帧只有1个, 其中包含所有内置函数的名称绑定, 而局部帧是每个函数都有的,属于自己的独立局部帧.它只能有该函数䣂访问.

调用用户自定义的函数时, 为了把参数应用到函数里边, 会有如下操作:
1. 在新的局部帧中, 把函数的形式参数绑定到实参的值上, 如f(2) 即把x这个名称绑定到2这个值上.
2. 从该帧开始到全局帧结束求出函数的主体

调用函数示例:
```python
from operator import add, mul


def square(x):
        return mul(x, x)
        
        
def sum_squares(x, y):
        return add(square(x), square(y))
        

sum_squares(5, 12)
```

